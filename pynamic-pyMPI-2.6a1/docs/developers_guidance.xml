<?xml encoding='UTF-8'?>
<report title="Developers guidance" author="Pat Miller">


<section title="FILE NAMES">
File names should be obviously connected with pyMPI.  This helps when
assertions toss, so panics will look like:
<verbatim>
 pyMPI_foobar:36: Assertion failure                               
</verbatim>
C source files are of the form pyMPI_xxxxx where xxxx indicates
the functionality implemented by the file.

Some large implementations are broken up, e.g. pyMPI_comm_xxxx.c
and pyMPI_comm_yyyy.c are part of the implemenation of pyMPI_comm.c

Header files are of the form pyMPI_Xxxxx.h  The pyMPI_Macros.h file
is for internal implementation only.  The normal user working through
the API would start their file.
<c style="fixed">
#include "mpi.h"
#include "Python.h"
#include "pyMPI.h"
</c>
Implementation files add the internal macros in explicitly.
<c style="fixed">
#include "mpi.h"
#include "Python.h"
#include "pyMPI.h"
#include "pyMPI_Macros.h"
</c>

</section>

<section title="Symbols">

The preferred name convention is words separated by underscore.  Many
older names are in CamelCase, but the trend is toward the underscores
(in some ways, more MPI stylish rather than Python internals).

All global symbols are of the form pyMPI_ffff_yyyy where
ffff makes reference to the file of origin.  The yyy is
underscore separated words where each piece is either an
acronym (all in upper case) or a word.

All macro names are upper case words separated by underscores.  The
names start with PYMPI.

Type names are of the form PyMPI_Type_Name.

</section>

<section title="Refcounting guidance">
Use /*borrowed*/, /*owned*/, /*incs*/, and /*noincs*/ to guide understanding
of Python reference counts.  Each PyObject* should be either (a) borrowed
or 0 though the whole of an function body or (b) owned or 0 through the
whole of a function body.
</section>

<section title="Declarations">
All function prototypes are single line.

All local variables are declared one to a line.

All pointers are to be initialized to either 0 or some appropriate
default value.

Pointer declarations are to cuddle the * to the type name, that is
foo* pointer = 0;
not
foo *pointer = 0;

Use 0, not NULL for the uninitialized pointer.

Local variables are to be declared roughly in order of use.

The value of the PyObject* value returned by a function should
be called "result"

</section>

<section title="Style">
Put the open brace on the  same line as the function prototype, for, if, while, or case.

Use /*****/ boxes for major sections (see comment-box discussion below),
/*-------------*/ boxes for subsections of a function, and 
/* comment */ one line comments elsewhere.  Multi-line comments are
not to be used
<c style="fixed">
/*
** Do not use this style
*/
</c>
   Use:
<c style="fixed">

/* Short description of immediate next line */
operation

or
this_thing = something_else;  /* very small */

or preferably

/* ----------------------------------------------- */
/* Describe section of code that follows           */
/* ----------------------------------------------- */
for(...) {
}
</c>

<c style="fixed">/* TODO: description */</c> to describe future work areas.  These
are picked up by the utils/grind_docs_and_prototypes.py utility and
marked as warnings to the developer.

Use #if 0/#endif to "comment out code"
<c style="fixed">
#if 0
   /* This code is dead */
#endif
</c>

if statements are of the form
<c style="fixed">

if ( test ) very_simple();

if ( test ) {
  work();
}

if ( test ) {
  work();
} else {
  other_work():
}
</c>

if-then-elseif-else statements have two forms depending on whether
   it is more logic branch like or caselike.  Caselike form requires
   comments describing each case.

<c style="fixed">

if ( test ) {
   work();
} else if ( test2 ) {
   work2();
} else {
   work3();
}

   or

/* ----------------------------------------------- */
/* describe case 1                                 */
/* ----------------------------------------------- */
if ( test ) {
   work();
}

/* ----------------------------------------------- */
/* describe case 2                                 */
/* ----------------------------------------------- */
else if ( test2 ) {
   work2();
}

/* ----------------------------------------------- */
/* describe case 3                                 */
/* ----------------------------------------------- */
else {
   work3();
}
</c>

for, do, and while loops ALWAYS use {}

</section>

<section title="Comment boxes">
The code uses comment boxes to support autogenerated documentation
and external header generation, so it is important to follow
the convention.  Note that pyMPI_Externals.h is autogenerated
and is not to be hand-editted.

Each box looks like
<c style="fixed">
/***********************************************************/
/* KIND  **************        nameish_thing       *********/
/***********************************************************/
/* Arg1 text                                               */
/***********************************************************/
/* Arg2 text                                               */
/***********************************************************/
item_being_described ...
</c>

<p/>The kind (one of FILE, LOCAL, GLOBAL, MACRO, METHOD, GMETHOD) defines how
many argument boxes follow (typically 1, the FILE and *METHOD boxes have two).
The width is arbitrary, but 77 characters is typical.  The item being described
MUST immediately follow the box.  All lines are closed comments (i.e. starts
with /* and ends with */.  This convention is to be held to even when C++
code is added to the source base.

<subsection title="FILE">
  The FILE box requires an author line in the first argument box and then
  descriptive text of the file in the second.  E.g.
<c style="fixed">
/***********************************************************/
/* FILE   **************        pyMPI_comm.c       *********/
/***********************************************************/
/* Author: Patrick Miller May 17 2002                      */
/***********************************************************/
/* Top level communicator object description.  It is so    */
/* that it further broken into a series of smaller files   */
/*                                                         */
/* >>> from mpi import *                                   */
/* >>> import mpi                                          */
/* >>> comm = WORLD.comm_dup()                             */
/***********************************************************/
</c>

The lines that start with Python prompts are used at the head of every
microtest generated by the code.

</subsection>

<subsection title="LOCAL">
<c style="fixed">
/***********************************************************/
/* LOCAL  **************         comm_alloc        *********/
/***********************************************************/
/* Allocate a communicator structure with proper handling  */
/***********************************************************/
static PyObject* comm_alloc(PyTypeObject* T, int n) {
 ...
}
</c>
Note that the static, return type, prototype, and open brace are on a single
line.

</subsection>

<subsection title="GLOBAL">
Box type GLOBAL extends the LOCAL form.  As a side effect, a prototype
will be copied into the pyMPI_Externals.h file.  The name of the function
is checked to make sure it starts with pyMPI_ and also that it extends
the name (e.g. in the file pyMPI_init.c, function pyMPI_init_foobar is 
legal, but pyMPI_foop is not).
</subsection>

<subsection title="MACRO">
This simply documents a #define macro.
</subsection>

<subsection title="METHOD">
Box type Method extends the LOCAL form.  It expects a second box which
contains documentation.  The characters within are reformated into
a document string which is #defined and placed into pyMPI_Externals.h
Things that start with Python prompts are passed into the micro test directory.
<c style="fixed">
/***********************************************************/
/* METHOD **************         comm_free         *********/
/***********************************************************/
/* Implements MPI_Comm_free                                */
/***********************************************************/
/* Release the MPI communicator                            */
/*                                                         */
/* release() --> None                                      */
/*                                                         */
/* This tells MPI that the communicator is no longer in    */
/* and NULL communicators are not freed and the method     */
/*                                                         */
/* >>> comm.comm_free()                                    */
/*                                                         */
/***********************************************************/
</c>

Here, the macro PYMPI_COMM_FREE_DOC is defined to be "Release the ..."
A small test will be written which assures comm.comm_free() runs.

Note that this test will look something like:
<python>
from mpi import *
comm = WORLD.comm_dup()
comm.comm_free()
</python>

since it extends the startup code from the FILE box (see above).

</subsection>

<subsection title="GMETHOD">
Box type Method extends the METHOD and GLOBAL forms.
</subsection>

</section>


<section title="methods of built-in types">
All methods are to define keyword arguments and not rely on positional
arguments alone (except functions of no arguments).
The original Python argument is to be declared as PyObject* pySelf
and will be cast to the internal type as 
<c style="fixed">
PyMPI_type_name* self = (PyMPI_type_name*)pySelf;
</c>
</section>

</report>